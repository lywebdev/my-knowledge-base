**Domain Driven Design** - предметно-ориентированная парадигма проектирования. В этой парадигме ключевым понятием является
бизнес-логика, вокруг которой разрабатывается приложение.
<br>
Это не является технологией, а лишь набор принципов. DDD обязывает разработчика создавать абстракции, в которые
входит бизнес-логика. По сути, это связующее звено между продуктом (бизнесом) и программным кодом.
<br>
DDD основан на выделении логики в домены (domains).

Домен - это предметная область, для которой ведётся разработка.
<br>
В DDD ещё есть субдомены - они существуют для разделения одного круного домена на несколько небольших субдоменов.
Например, для онлайн-агенства можно выделить следующие субдомены:
- Ценообразование
- Инвентаризация
- Управление пользователями и т. д.

### Ubiquitous language
Это языка бизнеса. Чтобы общаться на нём в контексте проекта, нужно:
- Определить ключевые бизнес-процессы, их входы и выходы
- Создать глоссарий терминов и определений
- Определить важные концепции ПО с хорошей документацией
- Обмениваться этими знаниями со всеми членами команды (разработчиками и экспертами предметной области)

### Bounded context (ограниченный контекст)
Это некая граница, в которой существует модель предметной области.
<br>
На основании контекста код разделяют на папки/файлы/пакеты/компоненты таким образом, чтобы изменения в каждом из них
не оказывали (или оказывали минимальное) влияние на другие компоненты системы.
<br>
Это помогает разработчикам эффективно работать в команде, и смелее вносить изменения в код, не боясь, что где-то 
в другом месте другая модель будет затронута/сломана.

## Пример
Есть проект блога, в котором есть сущности:
- Post (модель поста). Может быть черновиком. Может быть лайкнут. У поста могут быть реакции. Посты хранят в себе кол-во просмотров.
- Author (модель пользователя). Хранит почту, имя, фамилию, позволяет их менять.

У всех сущностей будут бизнес-методы (addLike, removeLike, addReaction и т. д.) - тогда смело можно сказать,
что принцип **Ubiquitous language** соблюдён.


# FAQ
1. **Для чего нужны агрегаторы?**<br>
   Агрегаторы в DDD используются для определения границ транзакций и согласованности. Они представляют собой единицы, содержащие одну или несколько сущностей, обеспечивая инварианты (правила) внутри этих границ
2. **Для чего используются key-value объекты?**<br>
   Key-value объекты (или Value Objects) используются для представления неразделимых значений, таких как деньги или адреса, которые имеют логическую целостность. Они помогают избежать примитивной одержимости и делают код более выразительным и безопасным
3. **Зачем нужно создавать key-value объекты даже для простых полей, например id?**<br>
   Value Objects для идентификаторов и других полей создаются для того, чтобы выразить намерения и бизнес-логику более четко. Они помогают валидации и типобезопасности, обеспечивая целостность данных
4. **Можно ли вызывать в классах-агрегаторах сервисы, описанные в application слое?**<br>
   Нет, в классах доменного слоя (включая агрегаты) не следует вызывать сервисы из слоя приложения напрямую. Доменный слой должен быть независимым и не должен зависеть от внешних сервисов. Взаимодействие должно осуществляться через абстракции (интерфейсы), которые инвертируют зависимости и позволяют внедрять нужные реализации
5. **Где нужно хранить классы с интерфейсами репозиториев?**<br>
   Классы с интерфейсами репозиториев следует хранить в доменном слое (Domain Layer), так как они являются частью бизнес-логики
6. **Где нужно хранить классы с реализацией репозиториев?**<br>
   Классы с реализацией репозиториев должны находиться в инфраструктурном слое (Infrastructure Layer), так как они зависят от конкретных технологий для доступа к данным
7. **А для чего нужны поддиректории?**<br>
   Создавать поддиректории имеет смысл, если у вас много различных типов, например, репозиториев, или если проект имеет высокую сложность. Это помогает поддерживать структуру проекта организованной и понятной
8. **Где нужно хранить классы сервисов?**<br>
   Классы сервисов следует хранить в слое приложения (Application Layer), так как они содержат бизнес-логику и координируют работу между различными агрегатами, репозиториями и другими сервисами

# Пример структуры приложения
```
— App /
—— Application /
——— Services /
———— Order /
—— Domain /
——— Models /
———— Order /
——— Repositories /
———— Order /
—— Infrastructure /
——— Repositories /
———— Eloquent /
————— Order /
—— Presentation /
——— Api /
——— Web /
```

### Полезные сопутствующие знания 
**Что такое Value Object и Entity?**
- Value Object:
  - Не имеет уникального идентификатора
  - Представляет значение, которое неизменно
  - Сравнение происходит по значению
  - Примеры: деньги (Money), дата (Date), координаты (Coordinates)
- Entity:
  - Имеет уникальный идентификатор
  - Определяется своей идентичностью, а не состоянием
  - Примеры: пользователь (User), заказ (Order)


### Полезные ресурсы про DDD
- [[YouTube] DDD архитектура на практике](https://www.youtube.com/watch?v=6_BhdXLxiic)
- [Эрик Эванс. Domain Language](https://www.domainlanguage.com/)
- [Мартин Фаулер. проектирование Domain-Driven](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbGpyRWU5cS00TzhHdFc2c0tqTnQzcHBOczBqQXxBQ3Jtc0tuV2pETGc4Z3MwUldFWGtYY093TXlaZGdkdlQ4MFQxMTlZRXoxMXBaSmNQTXI5emM2Y2c2eHY1bEhVc3VVQlEtalZOOXVBNXQ1NFlkaUd5WG5KblFNei14bkVGQk95QjFOZy1YVk50STJvalpCTWh5TQ&q=https%3A%2F%2Fmartinfowler.com%2Ftags%2Fdomain%2520driven%2520design.html&v=6_BhdXLxiic)